{
  "language": "Solidity",
  "sources": {
    "contracts/modules/IValidationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IValidationModule {\n  function validate(bytes calldata arg) external returns (bool);\n}"
    },
    "contracts/modules/PrivadoIDValidatorModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../modules/IValidationModule.sol\";\n\ninterface ICircuitValidator {\n  // Variables\n  struct CircuitQuery {\n    string circuitId;\n    uint256 schema;\n    uint256 slotIndex;\n    uint256 operator;\n    uint256[] value;\n  }\n\n  struct Params {\n    uint256[] inputs;\n    uint256[2] a;\n    uint256[2][2] b;\n    uint256[2] c;\n  }\n\n  /**\n   * @dev verify\n   */\n  function verify(\n    uint256[] memory inputs,\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    CircuitQuery memory query\n  ) external view returns (bool r);\n\n  /**\n   * @dev getCircuitId\n   */\n  function getCircuitId() external pure returns (string memory id);\n\n  /**\n   * @dev getChallengeInputIndex\n   */\n  function getChallengeInputIndex() external pure returns (uint256 index);\n\n  /**\n   * @dev getUserIdInputIndex\n   */\n  function getUserIdInputIndex() external pure returns (uint256 index);\n}\n\n\n\ncontract PrivadoIDValidatorModule is IValidationModule {\n\n  address public PrivadoIDValidator;\n  ICircuitValidator.CircuitQuery public query;\n\n  constructor(ICircuitValidator.CircuitQuery memory _query, address _validator) {\n    PrivadoIDValidator = _validator;\n    \n    query = _query;\n  }\n\n  function validate(bytes calldata arg) external override returns (bool) {\n    ICircuitValidator.Params memory params = abi.decode(arg, (ICircuitValidator.Params));\n\n    require(ICircuitValidator(PrivadoIDValidator).verify(params.inputs, \n      params.a, \n      params.b, \n      params.c, \n      query\n    ), \"PrivadoID Verification Failed\");\n    \n    return true;\n  }\n}"
    },
    "contracts/modules/WorldcoinValidatorModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../modules/IValidationModule.sol\";\n\n\nstruct Input {\n  address signal;\n  uint256 root;\n  uint256 nullifierHash;\n  uint256[8] proof;\n}\n\nstruct Proof {\n    uint256 root;\n    uint256 groupId;\n    uint256 signalHash;\n    uint256 nullifierHash;\n    uint256 externalNullifierHash;\n    uint256[8] proof;\n  }\n\n\ninterface WorldcoinVerifier {\n  \n  function verifyProof(\n    uint256 root,\n    uint256 groupId,\n    uint256 signalHash,\n    uint256 nullifierHash,\n    uint256 externalNullifierHash,\n    uint256[8] calldata proof\n  ) external returns (bool);\n}\n\ncontract WorldcoinValidatorModule is IValidationModule {\n\n  address public worldcoinVerifier;\n\n  string _appId;\n  string _action;\n\n  constructor(address _verifier) {\n    worldcoinVerifier = _verifier;\n    \n    _appId = \"app_staging_671675a8edd5130f3a7b0d2f9bc7b11c\";\n    _action = \"commit2\";\n  }\n  \n\nfunction hashToField(bytes memory value) internal pure returns (uint256) {\n  return uint256(keccak256(abi.encodePacked(value))) >> 8;\n}\n\n  function validate(bytes calldata arg) external override returns (bool) {\n    // Decode args in Input struct\n    Input memory input = abi.decode(arg, (Input));\n\n    // Create Proof struct\n    Proof memory proof = Proof({\n      root: input.root,\n      groupId: 1,\n      signalHash: hashToField(abi.encodePacked(input.signal)),\n      nullifierHash: input.nullifierHash,\n      externalNullifierHash: hashToField(abi.encodePacked(hashToField(abi.encodePacked(_appId)), _action)),\n      proof: input.proof\n    }); \n  \n    require(WorldcoinVerifier(worldcoinVerifier).verifyProof(\n      proof.root,\n      proof.groupId,\n      proof.signalHash,\n      proof.nullifierHash,\n      proof.externalNullifierHash,\n      proof.proof\n    ), \"Worldcoin Verification Failed\");\n    \n    return true;\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}