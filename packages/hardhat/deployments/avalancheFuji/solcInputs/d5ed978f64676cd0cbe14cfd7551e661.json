{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/CommitProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./helpers/MerkleTreeWithHistory.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./modules/IValidationModule.sol\";\n\ninterface IVerifier {\n  function verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool);\n}\n\ncontract CommitProtocol is MerkleTreeWithHistory, ReentrancyGuard {\n  IVerifier public immutable verifier;\n \n  mapping(bytes32 => bool) public nullifierHashes;\n  // we store all commitments just to prevent accidental creations with the same commitment\n  mapping(bytes32 => bool) public commitments;\n\n  // commitments to validation modules \n  mapping(bytes32 => address[]) public validationModules;\n\n  event NewCode(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);\n  event ConsumeCode(address to, bytes32 nullifierHash);\n\n  /**\n    @dev The constructor\n    @param _verifier the address of SNARK verifier for this contract\n    @param _hasher the address of MiMC hash contract\n    @param _merkleTreeHeight the height of codes' Merkle Tree\n  */\n  constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight\n  ) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) {\n    verifier = _verifier;\n  }\n\n  /**\n    @dev Set new code.\n    @param _commitment the note commitment, which is PedersenHash(nullifier + secret)\n  */\n  function setCode(bytes32 _commitment, address[] calldata _validationModules) public virtual payable nonReentrant {\n    require(!commitments[_commitment], \"The commitment has been submitted\");\n\n    uint32 insertedIndex = _insert(_commitment);\n    commitments[_commitment] = true;\n\n    for (uint256 i = 0; i < _validationModules.length; i++) {\n      validationModules[_commitment].push(_validationModules[i]);\n    }\n\n    emit NewCode(_commitment, insertedIndex, block.timestamp);\n  }\n\n\n  /**\n    @dev Consume a code from the contract. `proof` is a zkSNARK proof data, and input is an array of circuit public inputs\n    `input` array consists of:\n      - merkle root of all codes in the contract\n      - hash of unique codes nullifier to prevent double spends\n      - the recipient of funds\n      - optional fee that goes to the transaction sender (usually a relay)\n  */\n  function consumeCode(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _recipient,\n    bytes[] calldata _validationsArgs\n  ) public virtual payable nonReentrant {\n    require(!nullifierHashes[_nullifierHash], \"The note has been already spent\");\n    require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one\n    \n    require(\n      verifier.verifyProof(\n        _proof,\n        [uint256(_root), uint256(_nullifierHash), uint256(uint160(address(_recipient))),0 ,0, 0]\n      ),\n      \"Invalid withdraw proof\"\n    );\n\n    for (uint256 i = 0; i < validationModules[_commitment].length; i++) {\n      IValidationModule(validationModules[_commitment][i]).validate(_validationsArgs[i]);\n    }\n\n    nullifierHashes[_nullifierHash] = true;\n\n    emit ConsumeCode(_recipient, _nullifierHash);\n  }\n\n  /** @dev whether a note is already spent */\n  function isSpent(bytes32 _nullifierHash) public view returns (bool) {\n    return nullifierHashes[_nullifierHash];\n  }\n\n  /** @dev whether an array of notes is already spent */\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) {\n    spent = new bool[](_nullifierHashes.length);\n    for (uint256 i = 0; i < _nullifierHashes.length; i++) {\n      if (isSpent(_nullifierHashes[i])) {\n        spent[i] = true;\n      }\n    }\n  }\n}\n"
    },
    "contracts/ERC721Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./CommitProtocol.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ncontract ERC721Transfer is CommitProtocol {\n  IERC721 public token;\n\n  mapping(bytes32 => uint256) public TransferId;\n\n   constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC721 _token\n  ) CommitProtocol(_verifier, _hasher, _merkleTreeHeight) {\n    token = _token;\n  }\n\n  function createTransfer(bytes32 _commitment, address[] calldata _validationModules, uint256 _id) public payable {\n    super.setCode(_commitment, _validationModules);\n\n    token.safeTransferFrom(msg.sender, address(this), _id);\n\n    TransferId[_commitment] = _id;\n  }\n\n  function consumeTransfer(\n  bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public {\n    super.consumeCode(_commitment,_proof, _root, _nullifierHash, _to, _validationsArgs);\n\n    uint256 id = TransferId[_commitment];\n\n    token.safeTransferFrom(address(this), _to, id);\n  }\n \n}"
    },
    "contracts/helpers/MerkleTreeWithHistory.sol": {
      "content": "// https://tornado.cash\n/*\n * d888888P                                           dP              a88888b.                   dP\n *    88                                              88             d8'   `88                   88\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\n *    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\n *    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IHasher {\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR);\n}\n\ncontract MerkleTreeWithHistory {\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\n  IHasher public immutable hasher;\n\n  uint32 public levels;\n\n  // the following variables are made public for easier testing and debugging and\n  // are not supposed to be accessed in regular code\n\n  // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\n  // it removes index range check on every interaction\n  mapping(uint256 => bytes32) public filledSubtrees;\n  mapping(uint256 => bytes32) public roots;\n  uint32 public constant ROOT_HISTORY_SIZE = 30;\n  uint32 public currentRootIndex = 0;\n  uint32 public nextIndex = 0;\n\n  constructor(uint32 _levels, IHasher _hasher) {\n    require(_levels > 0, \"_levels should be greater than zero\");\n    require(_levels < 32, \"_levels should be less than 32\");\n    levels = _levels;\n    hasher = _hasher;\n\n    for (uint32 i = 0; i < _levels; i++) {\n      filledSubtrees[i] = zeros(i);\n    }\n\n    roots[0] = zeros(_levels - 1);\n  }\n\n  /**\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\n  */\n  function hashLeftRight(\n    IHasher _hasher,\n    bytes32 _left,\n    bytes32 _right\n  ) public pure returns (bytes32) {\n    require(uint256(_left) < FIELD_SIZE, \"_left should be inside the field\");\n    require(uint256(_right) < FIELD_SIZE, \"_right should be inside the field\");\n    uint256 R = uint256(_left);\n    uint256 C = 0;\n    (R, C) = _hasher.MiMCSponge(R, C);\n    R = addmod(R, uint256(_right), FIELD_SIZE);\n    (R, C) = _hasher.MiMCSponge(R, C);\n    return bytes32(R);\n  }\n\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\n    uint32 _nextIndex = nextIndex;\n    require(_nextIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\n    uint32 currentIndex = _nextIndex;\n    bytes32 currentLevelHash = _leaf;\n    bytes32 left;\n    bytes32 right;\n\n    for (uint32 i = 0; i < levels; i++) {\n      if (currentIndex % 2 == 0) {\n        left = currentLevelHash;\n        right = zeros(i);\n        filledSubtrees[i] = currentLevelHash;\n      } else {\n        left = filledSubtrees[i];\n        right = currentLevelHash;\n      }\n      currentLevelHash = hashLeftRight(hasher, left, right);\n      currentIndex /= 2;\n    }\n\n    uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n    currentRootIndex = newRootIndex;\n    roots[newRootIndex] = currentLevelHash;\n    nextIndex = _nextIndex + 1;\n    return _nextIndex;\n  }\n\n  /**\n    @dev Whether the root is present in the root history\n  */\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\n    if (_root == 0) {\n      return false;\n    }\n    uint32 _currentRootIndex = currentRootIndex;\n    uint32 i = _currentRootIndex;\n    do {\n      if (_root == roots[i]) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != _currentRootIndex);\n    return false;\n  }\n\n  /**\n    @dev Returns the last root\n  */\n  function getLastRoot() public view returns (bytes32) {\n    return roots[currentRootIndex];\n  }\n\n  /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n  function zeros(uint256 i) public pure returns (bytes32) {\n    if (i == 0) return bytes32(0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c);\n    else if (i == 1) return bytes32(0x256a6135777eee2fd26f54b8b7037a25439d5235caee224154186d2b8a52e31d);\n    else if (i == 2) return bytes32(0x1151949895e82ab19924de92c40a3d6f7bcb60d92b00504b8199613683f0c200);\n    else if (i == 3) return bytes32(0x20121ee811489ff8d61f09fb89e313f14959a0f28bb428a20dba6b0b068b3bdb);\n    else if (i == 4) return bytes32(0x0a89ca6ffa14cc462cfedb842c30ed221a50a3d6bf022a6a57dc82ab24c157c9);\n    else if (i == 5) return bytes32(0x24ca05c2b5cd42e890d6be94c68d0689f4f21c9cec9c0f13fe41d566dfb54959);\n    else if (i == 6) return bytes32(0x1ccb97c932565a92c60156bdba2d08f3bf1377464e025cee765679e604a7315c);\n    else if (i == 7) return bytes32(0x19156fbd7d1a8bf5cba8909367de1b624534ebab4f0f79e003bccdd1b182bdb4);\n    else if (i == 8) return bytes32(0x261af8c1f0912e465744641409f622d466c3920ac6e5ff37e36604cb11dfff80);\n    else if (i == 9) return bytes32(0x0058459724ff6ca5a1652fcbc3e82b93895cf08e975b19beab3f54c217d1c007);\n    else if (i == 10) return bytes32(0x1f04ef20dee48d39984d8eabe768a70eafa6310ad20849d4573c3c40c2ad1e30);\n    else if (i == 11) return bytes32(0x1bea3dec5dab51567ce7e200a30f7ba6d4276aeaa53e2686f962a46c66d511e5);\n    else if (i == 12) return bytes32(0x0ee0f941e2da4b9e31c3ca97a40d8fa9ce68d97c084177071b3cb46cd3372f0f);\n    else if (i == 13) return bytes32(0x1ca9503e8935884501bbaf20be14eb4c46b89772c97b96e3b2ebf3a36a948bbd);\n    else if (i == 14) return bytes32(0x133a80e30697cd55d8f7d4b0965b7be24057ba5dc3da898ee2187232446cb108);\n    else if (i == 15) return bytes32(0x13e6d8fc88839ed76e182c2a779af5b2c0da9dd18c90427a644f7e148a6253b6);\n    else if (i == 16) return bytes32(0x1eb16b057a477f4bc8f572ea6bee39561098f78f15bfb3699dcbb7bd8db61854);\n    else if (i == 17) return bytes32(0x0da2cb16a1ceaabf1c16b838f7a9e3f2a3a3088d9e0a6debaa748114620696ea);\n    else if (i == 18) return bytes32(0x24a3b3d822420b14b5d8cb6c28a574f01e98ea9e940551d2ebd75cee12649f9d);\n    else if (i == 19) return bytes32(0x198622acbd783d1b0d9064105b1fc8e4d8889de95c4c519b3f635809fe6afc05);\n    else if (i == 20) return bytes32(0x29d7ed391256ccc3ea596c86e933b89ff339d25ea8ddced975ae2fe30b5296d4);\n    else if (i == 21) return bytes32(0x19be59f2f0413ce78c0c3703a3a5451b1d7f39629fa33abd11548a76065b2967);\n    else if (i == 22) return bytes32(0x1ff3f61797e538b70e619310d33f2a063e7eb59104e112e95738da1254dc3453);\n    else if (i == 23) return bytes32(0x10c16ae9959cf8358980d9dd9616e48228737310a10e2b6b731c1a548f036c48);\n    else if (i == 24) return bytes32(0x0ba433a63174a90ac20992e75e3095496812b652685b5e1a2eae0b1bf4e8fcd1);\n    else if (i == 25) return bytes32(0x019ddb9df2bc98d987d0dfeca9d2b643deafab8f7036562e627c3667266a044c);\n    else if (i == 26) return bytes32(0x2d3c88b23175c5a5565db928414c66d1912b11acf974b2e644caaac04739ce99);\n    else if (i == 27) return bytes32(0x2eab55f6ae4e66e32c5189eed5c470840863445760f5ed7e7b69b2a62600f354);\n    else if (i == 28) return bytes32(0x002df37a2642621802383cf952bf4dd1f32e05433beeb1fd41031fb7eace979d);\n    else if (i == 29) return bytes32(0x104aeb41435db66c3e62feccc1d6f5d98d0a0ed75d1374db457cf462e3a1f427);\n    else if (i == 30) return bytes32(0x1f3c6fd858e9a7d4b0d1f38e256a09d81d5a5e3c963987e2d4b814cfab7c6ebb);\n    else if (i == 31) return bytes32(0x2c7a07d20dff79d01fecedc1134284a8d08436606c93693b67e333f671bf69cc);\n    else revert(\"Index out of bounds\");\n  }\n}\n"
    },
    "contracts/modules/IValidationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IValidationModule {\n  function validate(bytes calldata arg) external returns (bool);\n}"
    },
    "contracts/useCases/AlephNFTAirdropper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ERC721Transfer.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract AlephNFTAirdropper is ERC721Transfer, IERC721Receiver {\n\n// Map for consumed AlephNFTs per campaign\n  mapping(bytes32 => uint256) public consumed;\n// Map for limit amount of AlephNFTs per campaign\n  mapping(bytes32 => uint256) public limits;\n\n  event Success(bool success);\n\n  constructor (\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC721 _token\n  ) ERC721Transfer(_verifier, _hasher, _merkleTreeHeight, _token) {  \n  }\n\n  // Implement the onERC721Received function\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external override returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  function createAlephNFTAirdrop(bytes32 _commitment, address[] calldata _validationModules, uint256 _id, uint256 limit) public payable  {\n    limits[_commitment] = limit;\n    \n    createTransfer(\n      _commitment,\n      _validationModules,\n      _id\n    );\n  }\n\n  function consumeAlephNFTAirdrop(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public  {\n    require(consumed[_commitment] < limits[_commitment], \"AlephNFTAirdropper: Limit reached\");\n\n    consumed[_commitment] += 1;\n    consumeTransfer(\n      _commitment,\n      _proof,\n      _root,\n      _nullifierHash,\n      _to,\n      _validationsArgs\n    );\n\n        emit Success(true);\n\n  }\n\n  function bulkCreateAlephNFTAirdrop(bytes32[] calldata _commitments, address[][] calldata _validationModules, uint256[] calldata _ids, uint256[] calldata _limits) external payable  {\n    require(_commitments.length == _ids.length, \"commitments and ids length mismatch\");\n    require(_commitments.length == _limits.length, \"commitments and limits length mismatch\");\n    require(_commitments.length == _validationModules.length, \"commitments and validationModules length mismatch\");\n\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      createAlephNFTAirdrop(_commitments[i], _validationModules[i], _ids[i], _limits[i]);\n    }\n  }\n\n  function bulkConsumeAlephNFTAirdrop(\n    bytes32[] calldata _commitments,\n    bytes[] calldata _proofs,\n    bytes32[] calldata _roots,\n    bytes32[] calldata _nullifierHashes,\n    address payable[] calldata _tos,\n    bytes[] calldata _validationsArgs\n  ) external  {\n    require(_commitments.length == _proofs.length, \"commitments and proofs length mismatch\");\n    require(_commitments.length == _roots.length, \"commitments and roots length mismatch\");\n    require(_commitments.length == _nullifierHashes.length, \"commitments and nullifierHashes length mismatch\");\n    require(_commitments.length == _tos.length, \"commitments and tos length mismatch\");\n    require(_commitments.length == _validationsArgs.length, \"commitments and validationsArgs length mismatch\");\n\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      consumeAlephNFTAirdrop(_commitments[i], _proofs[i], _roots[i], _nullifierHashes[i], _tos[i], _validationsArgs);\n    }\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}