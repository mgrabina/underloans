{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/CommitProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./helpers/MerkleTreeWithHistory.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./modules/IValidationModule.sol\";\n\ninterface IVerifier {\n  function verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool);\n}\n\ncontract CommitProtocol is MerkleTreeWithHistory, ReentrancyGuard {\n  IVerifier public immutable verifier;\n \n  mapping(bytes32 => bool) public nullifierHashes;\n  // we store all commitments just to prevent accidental creations with the same commitment\n  mapping(bytes32 => bool) public commitments;\n\n  // commitments to validation modules \n  mapping(bytes32 => address[]) public validationModules;\n\n  event NewCode(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);\n  event ConsumeCode(address to, bytes32 nullifierHash);\n\n  /**\n    @dev The constructor\n    @param _verifier the address of SNARK verifier for this contract\n    @param _hasher the address of MiMC hash contract\n    @param _merkleTreeHeight the height of codes' Merkle Tree\n  */\n  constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight\n  ) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) {\n    verifier = _verifier;\n  }\n\n  /**\n    @dev Set new code.\n    @param _commitment the note commitment, which is PedersenHash(nullifier + secret)\n  */\n  function setCode(bytes32 _commitment, address[] calldata _validationModules) public virtual payable nonReentrant {\n    require(!commitments[_commitment], \"The commitment has been submitted\");\n\n    uint32 insertedIndex = _insert(_commitment);\n    commitments[_commitment] = true;\n\n    for (uint256 i = 0; i < _validationModules.length; i++) {\n      validationModules[_commitment].push(_validationModules[i]);\n    }\n\n    emit NewCode(_commitment, insertedIndex, block.timestamp);\n  }\n\n\n  /**\n    @dev Consume a code from the contract. `proof` is a zkSNARK proof data, and input is an array of circuit public inputs\n    `input` array consists of:\n      - merkle root of all codes in the contract\n      - hash of unique codes nullifier to prevent double spends\n      - the recipient of funds\n      - optional fee that goes to the transaction sender (usually a relay)\n  */\n  function consumeCode(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _recipient,\n    bytes[] calldata _validationsArgs\n  ) public virtual payable nonReentrant {\n    require(!nullifierHashes[_nullifierHash], \"The note has been already spent\");\n    require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one\n    \n    require(\n      verifier.verifyProof(\n        _proof,\n        [uint256(_root), uint256(_nullifierHash), uint256(uint160(address(_recipient))),0 ,0, 0]\n      ),\n      \"Invalid withdraw proof\"\n    );\n\n    for (uint256 i = 0; i < validationModules[_commitment].length; i++) {\n      IValidationModule(validationModules[_commitment][i]).validate(_validationsArgs[i]);\n    }\n\n    nullifierHashes[_nullifierHash] = true;\n\n    emit ConsumeCode(_recipient, _nullifierHash);\n  }\n\n  /** @dev whether a note is already spent */\n  function isSpent(bytes32 _nullifierHash) public view returns (bool) {\n    return nullifierHashes[_nullifierHash];\n  }\n\n  /** @dev whether an array of notes is already spent */\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) {\n    spent = new bool[](_nullifierHashes.length);\n    for (uint256 i = 0; i < _nullifierHashes.length; i++) {\n      if (isSpent(_nullifierHashes[i])) {\n        spent[i] = true;\n      }\n    }\n  }\n}\n"
    },
    "contracts/ERC1155Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./CommitProtocol.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ncontract ERC1155Transfer is CommitProtocol {\n  IERC1155 public token;\n\n  mapping(bytes32 => uint256) public TransferIds;\n  mapping(bytes32 => uint256) public TransferAmounts;\n\n   constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC1155 _token\n  ) CommitProtocol(_verifier, _hasher, _merkleTreeHeight) {\n    token = _token;\n  }\n\n  function createTransfer(bytes32 _commitment, address[] calldata _validationModules, uint256 _id, uint256 _amount) public payable nonReentrant {\n    super.setCode(_commitment, _validationModules);\n\n    token.safeTransferFrom(msg.sender, address(this), _id, _amount, \"\");\n\n    TransferIds[_commitment] = _id;\n    TransferAmounts[_commitment] = _amount;\n  }\n\n  function consumeTransfer(\n  bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public nonReentrant {\n    super.consumeCode(_commitment, _proof, _root, _nullifierHash, _to, _validationsArgs);\n\n    uint256 id = TransferIds[_commitment];\n    uint256 amount = TransferAmounts[_commitment];\n\n    token.safeTransferFrom(address(this), _to, id, amount, \"\");\n  }\n}"
    },
    "contracts/ERC20Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./CommitProtocol.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ERC20Transfer is CommitProtocol {\n  IERC20 public token;\n\n  mapping(bytes32 => uint256) public TransferValues;\n\n   constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC20 _token\n  ) CommitProtocol(_verifier, _hasher, _merkleTreeHeight) {\n    token = _token;\n  }\n\n  function createTransfer(bytes32 _commitment, uint256 _value, address[] calldata _validationModules) public payable nonReentrant {\n    super.setCode(_commitment, _validationModules);\n\n    token.transferFrom(msg.sender, address(this), _value);\n\n    TransferValues[_commitment] = _value;\n  }\n\n  function consumeTransfer(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public nonReentrant {\n    super.consumeCode(_commitment, _proof, _root, _nullifierHash, _to, _validationsArgs );\n\n    uint256 value = TransferValues[_commitment];\n\n    token.transferFrom(address(this), _to, value);\n  }\n\n \n}"
    },
    "contracts/ERC721Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./CommitProtocol.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ncontract ERC721Transfer is CommitProtocol {\n  IERC721 public token;\n\n  mapping(bytes32 => uint256) public TransferId;\n\n   constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC721 _token\n  ) CommitProtocol(_verifier, _hasher, _merkleTreeHeight) {\n    token = _token;\n  }\n\n  function createTransfer(bytes32 _commitment, address[] calldata _validationModules, uint256 _id) public payable nonReentrant {\n    super.setCode(_commitment, _validationModules);\n\n    token.safeTransferFrom(msg.sender, address(this), _id);\n\n    TransferId[_commitment] = _id;\n  }\n\n  function consumeTransfer(\n  bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public nonReentrant {\n    super.consumeCode(_commitment,_proof, _root, _nullifierHash, _to, _validationsArgs);\n\n    uint256 id = TransferId[_commitment];\n\n    token.safeTransferFrom(address(this), _to, id);\n  }\n \n}"
    },
    "contracts/ETHTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./CommitProtocol.sol\";\n\ncontract ETHGiftCards is CommitProtocol {\n\n  mapping(bytes32 => uint256) public giftCardValues;\n\n  constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight\n  ) CommitProtocol(_verifier, _hasher, _merkleTreeHeight) {}\n\n  function createGiftCard(bytes32 _commitment, address[] calldata _validationModules) public payable nonReentrant {\n    super.setCode(_commitment, _validationModules);\n\n    require(msg.value > 0, \"value should be greater than 0\");\n\n    giftCardValues[_commitment] = msg.value;\n  }\n\n  function consumeGiftCard(\n  bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public nonReentrant {\n    super.consumeCode(_commitment,_proof, _root, _nullifierHash, _to, _validationsArgs);\n\n    uint256 value = giftCardValues[_commitment];\n  giftCardValues[_commitment] = 0;\n\n    (bool success, ) = _to.call{ value: value }(\"\");\n    require(success, \"payment to _to did not go thru\");\n  }\n}"
    },
    "contracts/helpers/Hasher.sol": {
      "content": "pragma solidity ^0.8.20; \ncontract Hasher { \n    function MiMCSponge(uint256 xL_in,uint256 xR_in) external pure returns(uint256,uint256) { \n        uint n = 220; \n        bytes32 ci = 0x0fbe43c36a80e36d7c7c584d4f8f3759fb51f0d66065d8a227b688d12488c5d4;\n        uint q = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n        uint xL = xL_in;\n        uint xR = xR_in;\n        uint t=xL;\n        uint b=mulmod(t, t, q);\n        uint c=mulmod(b, b, q);\n        uint d=mulmod(c, t, q);\n        xR=addmod(xR, d, q);\n        \n        for(uint i = 0; i < n-1; i++){\n            if (i<n-2 && i!=0){\n                ci = keccak256(abi.encodePacked(ci));\n            }\n            else if(i==n-2)\n            {\n                ci = 0;\n            }\n            (xL, xR)=(xR, xL);\n            t = addmod(uint(ci), xL, q);\n            \n            b = mulmod(t, t, q);\n            c = mulmod(b, b, q);\n            d = mulmod(c, t, q);\n            xR = addmod(xR, d, q);\n        }\n        return (xL, xR);\n    } \n\n} "
    },
    "contracts/helpers/MerkleTreeWithHistory.sol": {
      "content": "// https://tornado.cash\n/*\n * d888888P                                           dP              a88888b.                   dP\n *    88                                              88             d8'   `88                   88\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\n *    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\n *    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IHasher {\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR);\n}\n\ncontract MerkleTreeWithHistory {\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\n  IHasher public immutable hasher;\n\n  uint32 public levels;\n\n  // the following variables are made public for easier testing and debugging and\n  // are not supposed to be accessed in regular code\n\n  // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\n  // it removes index range check on every interaction\n  mapping(uint256 => bytes32) public filledSubtrees;\n  mapping(uint256 => bytes32) public roots;\n  uint32 public constant ROOT_HISTORY_SIZE = 30;\n  uint32 public currentRootIndex = 0;\n  uint32 public nextIndex = 0;\n\n  constructor(uint32 _levels, IHasher _hasher) {\n    require(_levels > 0, \"_levels should be greater than zero\");\n    require(_levels < 32, \"_levels should be less than 32\");\n    levels = _levels;\n    hasher = _hasher;\n\n    for (uint32 i = 0; i < _levels; i++) {\n      filledSubtrees[i] = zeros(i);\n    }\n\n    roots[0] = zeros(_levels - 1);\n  }\n\n  /**\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\n  */\n  function hashLeftRight(\n    IHasher _hasher,\n    bytes32 _left,\n    bytes32 _right\n  ) public pure returns (bytes32) {\n    require(uint256(_left) < FIELD_SIZE, \"_left should be inside the field\");\n    require(uint256(_right) < FIELD_SIZE, \"_right should be inside the field\");\n    uint256 R = uint256(_left);\n    uint256 C = 0;\n    (R, C) = _hasher.MiMCSponge(R, C);\n    R = addmod(R, uint256(_right), FIELD_SIZE);\n    (R, C) = _hasher.MiMCSponge(R, C);\n    return bytes32(R);\n  }\n\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\n    uint32 _nextIndex = nextIndex;\n    require(_nextIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\n    uint32 currentIndex = _nextIndex;\n    bytes32 currentLevelHash = _leaf;\n    bytes32 left;\n    bytes32 right;\n\n    for (uint32 i = 0; i < levels; i++) {\n      if (currentIndex % 2 == 0) {\n        left = currentLevelHash;\n        right = zeros(i);\n        filledSubtrees[i] = currentLevelHash;\n      } else {\n        left = filledSubtrees[i];\n        right = currentLevelHash;\n      }\n      currentLevelHash = hashLeftRight(hasher, left, right);\n      currentIndex /= 2;\n    }\n\n    uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n    currentRootIndex = newRootIndex;\n    roots[newRootIndex] = currentLevelHash;\n    nextIndex = _nextIndex + 1;\n    return _nextIndex;\n  }\n\n  /**\n    @dev Whether the root is present in the root history\n  */\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\n    if (_root == 0) {\n      return false;\n    }\n    uint32 _currentRootIndex = currentRootIndex;\n    uint32 i = _currentRootIndex;\n    do {\n      if (_root == roots[i]) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != _currentRootIndex);\n    return false;\n  }\n\n  /**\n    @dev Returns the last root\n  */\n  function getLastRoot() public view returns (bytes32) {\n    return roots[currentRootIndex];\n  }\n\n  /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n  function zeros(uint256 i) public pure returns (bytes32) {\n    if (i == 0) return bytes32(0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c);\n    else if (i == 1) return bytes32(0x256a6135777eee2fd26f54b8b7037a25439d5235caee224154186d2b8a52e31d);\n    else if (i == 2) return bytes32(0x1151949895e82ab19924de92c40a3d6f7bcb60d92b00504b8199613683f0c200);\n    else if (i == 3) return bytes32(0x20121ee811489ff8d61f09fb89e313f14959a0f28bb428a20dba6b0b068b3bdb);\n    else if (i == 4) return bytes32(0x0a89ca6ffa14cc462cfedb842c30ed221a50a3d6bf022a6a57dc82ab24c157c9);\n    else if (i == 5) return bytes32(0x24ca05c2b5cd42e890d6be94c68d0689f4f21c9cec9c0f13fe41d566dfb54959);\n    else if (i == 6) return bytes32(0x1ccb97c932565a92c60156bdba2d08f3bf1377464e025cee765679e604a7315c);\n    else if (i == 7) return bytes32(0x19156fbd7d1a8bf5cba8909367de1b624534ebab4f0f79e003bccdd1b182bdb4);\n    else if (i == 8) return bytes32(0x261af8c1f0912e465744641409f622d466c3920ac6e5ff37e36604cb11dfff80);\n    else if (i == 9) return bytes32(0x0058459724ff6ca5a1652fcbc3e82b93895cf08e975b19beab3f54c217d1c007);\n    else if (i == 10) return bytes32(0x1f04ef20dee48d39984d8eabe768a70eafa6310ad20849d4573c3c40c2ad1e30);\n    else if (i == 11) return bytes32(0x1bea3dec5dab51567ce7e200a30f7ba6d4276aeaa53e2686f962a46c66d511e5);\n    else if (i == 12) return bytes32(0x0ee0f941e2da4b9e31c3ca97a40d8fa9ce68d97c084177071b3cb46cd3372f0f);\n    else if (i == 13) return bytes32(0x1ca9503e8935884501bbaf20be14eb4c46b89772c97b96e3b2ebf3a36a948bbd);\n    else if (i == 14) return bytes32(0x133a80e30697cd55d8f7d4b0965b7be24057ba5dc3da898ee2187232446cb108);\n    else if (i == 15) return bytes32(0x13e6d8fc88839ed76e182c2a779af5b2c0da9dd18c90427a644f7e148a6253b6);\n    else if (i == 16) return bytes32(0x1eb16b057a477f4bc8f572ea6bee39561098f78f15bfb3699dcbb7bd8db61854);\n    else if (i == 17) return bytes32(0x0da2cb16a1ceaabf1c16b838f7a9e3f2a3a3088d9e0a6debaa748114620696ea);\n    else if (i == 18) return bytes32(0x24a3b3d822420b14b5d8cb6c28a574f01e98ea9e940551d2ebd75cee12649f9d);\n    else if (i == 19) return bytes32(0x198622acbd783d1b0d9064105b1fc8e4d8889de95c4c519b3f635809fe6afc05);\n    else if (i == 20) return bytes32(0x29d7ed391256ccc3ea596c86e933b89ff339d25ea8ddced975ae2fe30b5296d4);\n    else if (i == 21) return bytes32(0x19be59f2f0413ce78c0c3703a3a5451b1d7f39629fa33abd11548a76065b2967);\n    else if (i == 22) return bytes32(0x1ff3f61797e538b70e619310d33f2a063e7eb59104e112e95738da1254dc3453);\n    else if (i == 23) return bytes32(0x10c16ae9959cf8358980d9dd9616e48228737310a10e2b6b731c1a548f036c48);\n    else if (i == 24) return bytes32(0x0ba433a63174a90ac20992e75e3095496812b652685b5e1a2eae0b1bf4e8fcd1);\n    else if (i == 25) return bytes32(0x019ddb9df2bc98d987d0dfeca9d2b643deafab8f7036562e627c3667266a044c);\n    else if (i == 26) return bytes32(0x2d3c88b23175c5a5565db928414c66d1912b11acf974b2e644caaac04739ce99);\n    else if (i == 27) return bytes32(0x2eab55f6ae4e66e32c5189eed5c470840863445760f5ed7e7b69b2a62600f354);\n    else if (i == 28) return bytes32(0x002df37a2642621802383cf952bf4dd1f32e05433beeb1fd41031fb7eace979d);\n    else if (i == 29) return bytes32(0x104aeb41435db66c3e62feccc1d6f5d98d0a0ed75d1374db457cf462e3a1f427);\n    else if (i == 30) return bytes32(0x1f3c6fd858e9a7d4b0d1f38e256a09d81d5a5e3c963987e2d4b814cfab7c6ebb);\n    else if (i == 31) return bytes32(0x2c7a07d20dff79d01fecedc1134284a8d08436606c93693b67e333f671bf69cc);\n    else revert(\"Index out of bounds\");\n  }\n}\n"
    },
    "contracts/helpers/Verifier.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-05-12\n*/\n\n// https://tornado.cash Verifier.sol generated by trusted setup ceremony.\n/*\n* d888888P                                           dP              a88888b.                   dP\n*    88                                              88             d8'   `88                   88\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n*/\n// SPDX-License-Identifier: MIT\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.20;\n\nlibrary Pairing {\n  uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  struct G1Point {\n    uint256 X;\n    uint256 Y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n  }\n\n  /*\n   * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n   */\n  function negate(G1Point memory p) internal pure returns (G1Point memory) {\n    // The prime q in the base field F_q for G1\n    if (p.X == 0 && p.Y == 0) {\n      return G1Point(0, 0);\n    } else {\n      return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n    }\n  }\n\n  /*\n   * @return r the sum of two points of G1\n   */\n  function plus(\n    G1Point memory p1,\n    G1Point memory p2\n  ) internal view returns (G1Point memory r) {\n    uint256[4] memory input;\n    input[0] = p1.X;\n    input[1] = p1.Y;\n    input[2] = p2.X;\n    input[3] = p2.Y;\n    bool success;\n\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n    // Use \"invalid\" to make gas estimation work\n      switch success case 0 { invalid() }\n    }\n\n    require(success, \"pairing-add-failed\");\n  }\n\n  /*\n   * @return r the product of a point on G1 and a scalar, i.e.\n   *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n   *         points p.\n   */\n  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    uint256[3] memory input;\n    input[0] = p.X;\n    input[1] = p.Y;\n    input[2] = s;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n    // Use \"invalid\" to make gas estimation work\n      switch success case 0 { invalid() }\n    }\n    require(success, \"pairing-mul-failed\");\n  }\n\n  /* @return The result of computing the pairing check\n   *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n   *         For example,\n   *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n   */\n  function pairing(\n    G1Point memory a1,\n    G2Point memory a2,\n    G1Point memory b1,\n    G2Point memory b2,\n    G1Point memory c1,\n    G2Point memory c2,\n    G1Point memory d1,\n    G2Point memory d2\n  ) internal view returns (bool) {\n    G1Point[4] memory p1 = [a1, b1, c1, d1];\n    G2Point[4] memory p2 = [a2, b2, c2, d2];\n\n    uint256 inputSize = 24;\n    uint256[] memory input = new uint256[](inputSize);\n\n    for (uint256 i = 0; i < 4; i++) {\n      uint256 j = i * 6;\n      input[j + 0] = p1[i].X;\n      input[j + 1] = p1[i].Y;\n      input[j + 2] = p2[i].X[0];\n      input[j + 3] = p2[i].X[1];\n      input[j + 4] = p2[i].Y[0];\n      input[j + 5] = p2[i].Y[1];\n    }\n\n    uint256[1] memory out;\n    bool success;\n\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n    // Use \"invalid\" to make gas estimation work\n      switch success case 0 { invalid() }\n    }\n\n    require(success, \"pairing-opcode-failed\");\n\n    return out[0] != 0;\n  }\n}\n\ncontract Verifier {\n  uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n  using Pairing for *;\n\n  struct VerifyingKey {\n    Pairing.G1Point alfa1;\n    Pairing.G2Point beta2;\n    Pairing.G2Point gamma2;\n    Pairing.G2Point delta2;\n    Pairing.G1Point[7] IC;\n  }\n\n  struct Proof {\n    Pairing.G1Point A;\n    Pairing.G2Point B;\n    Pairing.G1Point C;\n  }\n\n  function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n    vk.alfa1 = Pairing.G1Point(uint256(20692898189092739278193869274495556617788530808486270118371701516666252877969), uint256(11713062878292653967971378194351968039596396853904572879488166084231740557279));\n    vk.beta2 = Pairing.G2Point([uint256(12168528810181263706895252315640534818222943348193302139358377162645029937006), uint256(281120578337195720357474965979947690431622127986816839208576358024608803542)], [uint256(16129176515713072042442734839012966563817890688785805090011011570989315559913), uint256(9011703453772030375124466642203641636825223906145908770308724549646909480510)]);\n    vk.gamma2 = Pairing.G2Point([uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634), uint256(10857046999023057135944570762232829481370756359578518086990519993285655852781)], [uint256(4082367875863433681332203403145435568316851327593401208105741076214120093531), uint256(8495653923123431417604973247489272438418190587263600148770280649306958101930)]);\n    vk.delta2 = Pairing.G2Point([uint256(21280594949518992153305586783242820682644996932183186320680800072133486887432), uint256(150879136433974552800030963899771162647715069685890547489132178314736470662)], [uint256(1081836006956609894549771334721413187913047383331561601606260283167615953295), uint256(11434086686358152335540554643130007307617078324975981257823476472104616196090)]);\n    vk.IC[0] = Pairing.G1Point(uint256(16225148364316337376768119297456868908427925829817748684139175309620217098814), uint256(5167268689450204162046084442581051565997733233062478317813755636162413164690));\n    vk.IC[1] = Pairing.G1Point(uint256(12882377842072682264979317445365303375159828272423495088911985689463022094260), uint256(19488215856665173565526758360510125932214252767275816329232454875804474844786));\n    vk.IC[2] = Pairing.G1Point(uint256(13083492661683431044045992285476184182144099829507350352128615182516530014777), uint256(602051281796153692392523702676782023472744522032670801091617246498551238913));\n    vk.IC[3] = Pairing.G1Point(uint256(9732465972180335629969421513785602934706096902316483580882842789662669212890), uint256(2776526698606888434074200384264824461688198384989521091253289776235602495678));\n    vk.IC[4] = Pairing.G1Point(uint256(8586364274534577154894611080234048648883781955345622578531233113180532234842), uint256(21276134929883121123323359450658320820075698490666870487450985603988214349407));\n    vk.IC[5] = Pairing.G1Point(uint256(4910628533171597675018724709631788948355422829499855033965018665300386637884), uint256(20532468890024084510431799098097081600480376127870299142189696620752500664302));\n    vk.IC[6] = Pairing.G1Point(uint256(15335858102289947642505450692012116222827233918185150176888641903531542034017), uint256(5311597067667671581646709998171703828965875677637292315055030353779531404812));\n\n  }\n\n  /*\n   * @returns Whether the proof is valid given the hardcoded verifying key\n   *          above and the public inputs\n   */\n  function verifyProof(\n    bytes memory proof,\n    uint256[6] memory input\n  ) public view returns (bool) {\n    uint256[8] memory p = abi.decode(proof, (uint256[8]));\n\n    // Make sure that each element in the proof is less than the prime q\n    for (uint8 i = 0; i < p.length; i++) {\n      require(p[i] < PRIME_Q, \"verifier-proof-element-gte-prime-q\");\n    }\n\n    Proof memory _proof;\n    _proof.A = Pairing.G1Point(p[0], p[1]);\n    _proof.B = Pairing.G2Point([p[2], p[3]], [p[4], p[5]]);\n    _proof.C = Pairing.G1Point(p[6], p[7]);\n\n    VerifyingKey memory vk = verifyingKey();\n\n    // Compute the linear combination vk_x\n    Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n    vk_x = Pairing.plus(vk_x, vk.IC[0]);\n\n    // Make sure that every input is less than the snark scalar field\n    for (uint256 i = 0; i < input.length; i++) {\n      require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n      vk_x = Pairing.plus(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));\n    }\n\n    return Pairing.pairing(\n      Pairing.negate(_proof.A),\n      _proof.B,\n      vk.alfa1,\n      vk.beta2,\n      vk_x,\n      vk.gamma2,\n      _proof.C,\n      vk.delta2\n    );\n  }\n}\n"
    },
    "contracts/modules/IValidationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IValidationModule {\n  function validate(bytes calldata arg) external returns (bool);\n}"
    },
    "contracts/modules/PrivadoIDValidatorModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../modules/IValidationModule.sol\";\n\ninterface ICircuitValidator {\n  // Variables\n  struct CircuitQuery {\n    string circuitId;\n    uint256 schema;\n    uint256 slotIndex;\n    uint256 operator;\n    uint256[] value;\n  }\n\n  struct Params {\n    uint256[] inputs;\n    uint256[2] a;\n    uint256[2][2] b;\n    uint256[2] c;\n  }\n\n  /**\n   * @dev verify\n   */\n  function verify(\n    uint256[] memory inputs,\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    CircuitQuery memory query\n  ) external view returns (bool r);\n\n  /**\n   * @dev getCircuitId\n   */\n  function getCircuitId() external pure returns (string memory id);\n\n  /**\n   * @dev getChallengeInputIndex\n   */\n  function getChallengeInputIndex() external pure returns (uint256 index);\n\n  /**\n   * @dev getUserIdInputIndex\n   */\n  function getUserIdInputIndex() external pure returns (uint256 index);\n}\n\n\n\ncontract PrivadoIDValidatorModule is IValidationModule {\n\n  address public PrivadoIDValidator;\n  ICircuitValidator.CircuitQuery public query;\n\n  constructor(ICircuitValidator.CircuitQuery memory _query) {\n    PrivadoIDValidator = 0x8c99F13dc5083b1E4c16f269735EaD4cFbc4970d; // Amoy Tesnet Address validator @todo: move to deploy script\n    \n    query = _query;\n  }\n\n  function validate(bytes calldata arg) external override returns (bool) {\n    ICircuitValidator.Params memory params = abi.decode(arg, (ICircuitValidator.Params));\n\n    require(ICircuitValidator(PrivadoIDValidator).verify(params.inputs, \n      params.a, \n      params.b, \n      params.c, \n      query\n    ), \"PrivadoID Verification Failed\");\n    \n    return true;\n  }\n}"
    },
    "contracts/modules/TestValidatorModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../modules/IValidationModule.sol\";\n\ncontract TestValidatorModule is IValidationModule {\n\n  function validate(bytes calldata arg) external override returns (bool) {\n    return true;\n  }\n}"
    },
    "contracts/modules/WorldcoinValidatorModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../modules/IValidationModule.sol\";\n\n\ninterface WorldcoinVerifier {\n  function verifyProof(\n    bytes calldata args\n  ) external returns (bool);\n}\n\ncontract WorldcoinValidatorModule is IValidationModule {\n\n  address public worldcoinVerifier;\n\n  constructor() {\n    worldcoinVerifier = 0x11cA3127182f7583EfC416a8771BD4d11Fae4334; // Sepolia Tesnet Address @todo: move to deploy script\n  }\n  \n\n\n  function validate(bytes calldata arg) external override returns (bool) {\n    require(WorldcoinVerifier(worldcoinVerifier).verifyProof(\n      arg\n    ), \"Worldcoin Verification Failed\");\n    \n    return true;\n  }\n}"
    },
    "contracts/useCases/EarlyAccessCodes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../CommitProtocol.sol\";\n\ncontract EarlyAccessCodes is CommitProtocol {\n\n  constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight\n  ) CommitProtocol(_verifier, _hasher, _merkleTreeHeight) {}\n\n  function createEarlyAccessCode(bytes32 _commitment, address[] calldata _validationModules) public payable {\n    super.setCode(_commitment, _validationModules);\n  }\n\n  function consumeEarlyAccessCode(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public {\n    super.consumeCode(_commitment,_proof, _root, _nullifierHash, _to, _validationsArgs);\n  }\n\n  function bulkCreateEarlyAccessCodes(bytes32[] calldata _commitments, address[][] calldata _validationModules) public payable {\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      createEarlyAccessCode(_commitments[i], _validationModules[i]);\n    }\n  }\n\n  function bulkConsumeEarlyAccessCodes(\n    bytes32[] calldata _commitments,\n    bytes[] calldata _proofs,\n    bytes32[] calldata _roots,\n    bytes32[] calldata _nullifierHashes,\n    address payable[] calldata _tos,\n    bytes[] calldata _validationsArgs\n  ) public {\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      consumeEarlyAccessCode(_commitments[i], _proofs[i], _roots[i], _nullifierHashes[i], _tos[i], _validationsArgs);\n    }\n  }\n}"
    },
    "contracts/useCases/EarlyAccessCodesTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./EarlyAccessCodes.sol\";\n\ncontract EarlyAccessCodesTestContract {\n  EarlyAccessCodes public earlyAccessCodes;\n  constructor(EarlyAccessCodes _earlyAccessCodes) {\n    earlyAccessCodes = _earlyAccessCodes;\n  }\n\n  event Success(bool success);\n\n  function testFunction(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    bytes[] calldata _validationsArgs\n  ) external {\n    earlyAccessCodes.consumeEarlyAccessCode(_commitment, _proof, _root, _nullifierHash, payable(msg.sender), _validationsArgs);\n  \n    emit Success(true);\n  }\n    \n}"
    },
    "contracts/useCases/GiftCards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ERC20Transfer.sol\";\n\ncontract GiftCards is ERC20Transfer {\n\n  // Mapping for gift card's metadata\n  mapping(bytes32 => string) public metadata;\n\n  constructor (\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC20 _token\n  ) ERC20Transfer(_verifier, _hasher, _merkleTreeHeight, _token) {  }\n\n  function createGiftCard(bytes32 _commitment, address[] calldata _validationModules, uint256 _value, string memory _metadata) public payable  {\n    metadata[_commitment] = _metadata;\n\n    super.createTransfer(\n      _commitment,\n      _value,\n      _validationModules\n    );\n  }\n\n  function consumeGiftCard(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public  {\n    super.consumeTransfer(\n      _commitment,\n      _proof,\n      _root,\n      _nullifierHash,\n      _to,\n      _validationsArgs\n    );\n  }\n\n  function bulkCreateGiftCard(bytes32[] calldata _commitments, address[][] calldata _validationModules, uint256[] calldata _values, string[] calldata _metadata) external payable  {\n    require(_commitments.length == _values.length, \"commitments and values length mismatch\");\n    require(_commitments.length == _metadata.length, \"commitments and metadata length mismatch\");\n    require(_commitments.length == _validationModules.length, \"commitments and validationModules length mismatch\");\n\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      createGiftCard(_commitments[i], _validationModules[i], _values[i], _metadata[i]);\n    }\n  }\n\n  function bulkConsumeGifCard(\n    bytes32[] calldata _commitments,\n    bytes[] calldata _proofs,\n    bytes32[] calldata _roots,\n    bytes32[] calldata _nullifierHashes,\n    address payable[] calldata _tos,\n    bytes[] calldata _validationsArgs\n  ) external  {\n    require(_commitments.length == _proofs.length, \"commitments and proofs length mismatch\");\n    require(_commitments.length == _roots.length, \"commitments and roots length mismatch\");\n    require(_commitments.length == _nullifierHashes.length, \"commitments and nullifierHashes length mismatch\");\n    require(_commitments.length == _tos.length, \"commitments and tos length mismatch\");\n    require(_commitments.length == _validationsArgs.length, \"commitments and validationsArgs length mismatch\");\n\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      consumeGiftCard(\n        _commitments[i],\n        _proofs[i],\n        _roots[i],\n        _nullifierHashes[i],\n        _tos[i],\n        _validationsArgs\n      );\n    }\n  }\n}"
    },
    "contracts/useCases/NumberContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./EarlyAccessCodes.sol\";\n\ncontract NumberContract {\n  EarlyAccessCodes public earlyAccessCodes;\n\n  constructor(EarlyAccessCodes _earlyAccessCodes) {\n    earlyAccessCodes = _earlyAccessCodes;\n  }\n\n  event Success(bool success);\n\n  uint256 public number;\n\n  function setNumber (\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    bytes[] calldata _validationsArgs,\n    uint256 _number\n  ) external {\n    earlyAccessCodes.consumeEarlyAccessCode(_commitment, _proof, _root, _nullifierHash, payable(msg.sender), _validationsArgs);\n  \n    number = _number;\n\n    emit Success(true);\n  }\n    \n}"
    },
    "contracts/useCases/POAPAirdropper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ERC721Transfer.sol\";\n\ncontract POAPAirdropper is ERC721Transfer {\n\n// Map for consumed poaps per campaign\n  mapping(bytes32 => uint256) public consumed;\n// Map for limit amount of poaps per campaign\n  mapping(bytes32 => uint256) public limits;\n\n  constructor (\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC721 _token\n  ) ERC721Transfer(_verifier, _hasher, _merkleTreeHeight, _token) {  \n  }\n\n  function createPOAPAirdrop(bytes32 _commitment, address[] calldata _validationModules, uint256 _id, uint256 limit) public payable  {\n    limits[_commitment] = limit;\n    \n    createTransfer(\n      _commitment,\n      _validationModules,\n      _id\n    );\n  }\n\n  function consumePOAPAirdrop(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs\n  ) public  {\n    require(consumed[_commitment] < limits[_commitment], \"POAPAirdropper: Limit reached\");\n\n    consumed[_commitment] += 1;\n    consumeTransfer(\n      _commitment,\n      _proof,\n      _root,\n      _nullifierHash,\n      _to,\n      _validationsArgs\n    );\n  }\n\n  function bulkCreatePOAPAirdrop(bytes32[] calldata _commitments, address[][] calldata _validationModules, uint256[] calldata _ids, uint256[] calldata _limits) external payable  {\n    require(_commitments.length == _ids.length, \"commitments and ids length mismatch\");\n    require(_commitments.length == _limits.length, \"commitments and limits length mismatch\");\n    require(_commitments.length == _validationModules.length, \"commitments and validationModules length mismatch\");\n\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      createPOAPAirdrop(_commitments[i], _validationModules[i], _ids[i], _limits[i]);\n    }\n  }\n\n  function bulkConsumePOAPAirdrop(\n    bytes32[] calldata _commitments,\n    bytes[] calldata _proofs,\n    bytes32[] calldata _roots,\n    bytes32[] calldata _nullifierHashes,\n    address payable[] calldata _tos,\n    bytes[] calldata _validationsArgs\n  ) external  {\n    require(_commitments.length == _proofs.length, \"commitments and proofs length mismatch\");\n    require(_commitments.length == _roots.length, \"commitments and roots length mismatch\");\n    require(_commitments.length == _nullifierHashes.length, \"commitments and nullifierHashes length mismatch\");\n    require(_commitments.length == _tos.length, \"commitments and tos length mismatch\");\n    require(_commitments.length == _validationsArgs.length, \"commitments and validationsArgs length mismatch\");\n\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      consumePOAPAirdrop(_commitments[i], _proofs[i], _roots[i], _nullifierHashes[i], _tos[i], _validationsArgs);\n    }\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}